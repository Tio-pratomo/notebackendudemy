---
title: "Full REST API Interaction"
---

Setelah mempelajari API fundamentals, authentication, dan Axios di sesi sebelumnya, sekarang kita akan mengintegrasikan semua konsep tersebut dalam aplikasi lengkap yang berinteraksi dengan REST API secara komprehensif. Sesi ini akan fokus pada implementasi CRUD operations, error handling yang robust, dan validation.

## CRUD Operations: Create, Read, Update, Delete

CRUD adalah empat operasi fundamental dalam persistent storage yang mapping dengan HTTP methods dalam REST API.

### Mapping CRUD ke HTTP Methods

| CRUD Operation | HTTP Method | Endpoint Example                   | Purpose               |
| -------------- | ----------- | ---------------------------------- | --------------------- |
| **Create**     | POST        | `/api/users`                       | Membuat resource baru |
| **Read**       | GET         | `/api/users` atau `/api/users/:id` | Mengambil data        |
| **Update**     | PUT/PATCH   | `/api/users/:id`                   | Update data           |
| **Delete**     | DELETE      | `/api/users/:id`                   | Menghapus data        |

## Project: Secrets API Application

Mari kita buat aplikasi lengkap yang mengintegrasikan external API dengan CRUD operations. Kita akan membuat aplikasi untuk mengelola secrets (rahasia) dengan fitur filtering, sorting, dan full CRUD.

### Setup Project

```bash
mkdir secrets-app
cd secrets-app
npm init -y
npm install express axios dotenv
npm install --save-dev nodemon
```

### Struktur File

```
secrets-app/
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ styles/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ style.css
‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ index.js
‚îî‚îÄ‚îÄ package.json
```

### File .env

```
API_BASE_URL=https://secrets-api.appbrewery.com
PORT=3000
```

### File index.js - Complete Application

```javascript
import express from "express";
import axios from "axios";
import dotenv from "dotenv";
import path from "path";
import { fileURLToPath } from "url";

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const port = process.env.PORT || 3000;
const API_BASE_URL = process.env.API_BASE_URL;

// ============================================
// MIDDLEWARE
// ============================================

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static("public"));

// Request logger middleware
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
});

// ============================================
// AXIOS INSTANCE CONFIGURATION
// ============================================

const secretsAPI = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
  headers: {
    "Content-Type": "application/json",
  },
});

// Request interceptor
secretsAPI.interceptors.request.use(
  (config) => {
    console.log(`API Request: ${config.method.toUpperCase()} ${config.url}`);
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor
secretsAPI.interceptors.response.use(
  (response) => {
    console.log(`API Response: ${response.status} ${response.statusText}`);
    return response;
  },
  (error) => {
    console.error(`API Error: ${error.response?.status || "Network Error"}`);
    return Promise.reject(error);
  }
);

// ============================================
// ERROR CLASSES
// ============================================

class APIError extends Error {
  constructor(message, statusCode, details = null) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
    this.name = "APIError";
  }
}

class ValidationError extends Error {
  constructor(message, field = null) {
    super(message);
    this.statusCode = 400;
    this.field = field;
    this.name = "ValidationError";
  }
}

// ============================================
// VALIDATION FUNCTIONS
// ============================================

function validateSecret(data) {
  const errors = [];

  if (!data.secret || typeof data.secret !== "string") {
    errors.push({
      field: "secret",
      message: "Secret is required and must be a string",
    });
  }

  if (data.secret && data.secret.length < 5) {
    errors.push({
      field: "secret",
      message: "Secret must be at least 5 characters",
    });
  }

  if (
    data.score &&
    (typeof data.score !== "number" || data.score < 0 || data.score > 10)
  ) {
    errors.push({
      field: "score",
      message: "Score must be a number between 0 and 10",
    });
  }

  if (errors.length > 0) {
    throw new ValidationError("Validation failed", errors);
  }

  return true;
}

function validateFilter(filter) {
  const validFilters = ["score", "username", "embarrassment"];
  if (filter && !validFilters.includes(filter)) {
    throw new ValidationError(
      `Invalid filter. Must be one of: ${validFilters.join(", ")}`
    );
  }
  return true;
}

// ============================================
// ROUTES - READ OPERATIONS
// ============================================

// GET - Get all secrets
app.get("/api/secrets", async (req, res, next) => {
  try {
    const response = await secretsAPI.get("/secrets");

    res.json({
      success: true,
      count: response.data.length,
      data: response.data,
    });
  } catch (error) {
    next(new APIError("Failed to fetch secrets", 500, error.message));
  }
});

// GET - Get random secret
app.get("/api/secrets/random", async (req, res, next) => {
  try {
    const response = await secretsAPI.get("/random");

    res.json({
      success: true,
      data: response.data,
    });
  } catch (error) {
    next(new APIError("Failed to fetch random secret", 500, error.message));
  }
});

// GET - Get secret by ID
app.get("/api/secrets/:id", async (req, res, next) => {
  const secretId = req.params.id;

  try {
    const response = await secretsAPI.get(`/secrets/${secretId}`);

    res.json({
      success: true,
      data: response.data,
    });
  } catch (error) {
    if (error.response?.status === 404) {
      next(new APIError("Secret not found", 404));
    } else {
      next(new APIError("Failed to fetch secret", 500, error.message));
    }
  }
});

// GET - Filter secrets
app.get("/api/secrets/filter/:filterType", async (req, res, next) => {
  const filterType = req.params.filterType;

  try {
    validateFilter(filterType);

    const response = await secretsAPI.get(`/filter`, {
      params: {
        [filterType]: req.query.value,
      },
    });

    res.json({
      success: true,
      filter: filterType,
      count: response.data.length,
      data: response.data,
    });
  } catch (error) {
    if (error instanceof ValidationError) {
      next(error);
    } else {
      next(new APIError("Failed to filter secrets", 500, error.message));
    }
  }
});

// ============================================
// ROUTES - CREATE OPERATION
// ============================================

// POST - Create new secret
app.post("/api/secrets", async (req, res, next) => {
  try {
    // Validate input
    validateSecret(req.body);

    const newSecret = {
      secret: req.body.secret,
      score: req.body.score || 5,
      username: req.body.username || "Anonymous",
      embarrassmentLevel: req.body.embarrassmentLevel || "medium",
    };

    const response = await secretsAPI.post("/secrets", newSecret);

    res.status(201).json({
      success: true,
      message: "Secret created successfully",
      data: response.data,
    });
  } catch (error) {
    if (error instanceof ValidationError) {
      next(error);
    } else if (error.response?.status === 400) {
      next(new APIError("Bad request", 400, error.response.data));
    } else {
      next(new APIError("Failed to create secret", 500, error.message));
    }
  }
});

// ============================================
// ROUTES - UPDATE OPERATIONS
// ============================================

// PUT - Full update (replace entire resource)
app.put("/api/secrets/:id", async (req, res, next) => {
  const secretId = req.params.id;

  try {
    // Validate input
    validateSecret(req.body);

    const updatedSecret = {
      secret: req.body.secret,
      score: req.body.score,
      username: req.body.username,
      embarrassmentLevel: req.body.embarrassmentLevel,
    };

    const response = await secretsAPI.put(
      `/secrets/${secretId}`,
      updatedSecret
    );

    res.json({
      success: true,
      message: "Secret updated successfully",
      data: response.data,
    });
  } catch (error) {
    if (error instanceof ValidationError) {
      next(error);
    } else if (error.response?.status === 404) {
      next(new APIError("Secret not found", 404));
    } else {
      next(new APIError("Failed to update secret", 500, error.message));
    }
  }
});

// PATCH - Partial update (update specific fields)
app.patch("/api/secrets/:id", async (req, res, next) => {
  const secretId = req.params.id;

  try {
    // For PATCH, only validate fields that are provided
    if (req.body.secret && req.body.secret.length < 5) {
      throw new ValidationError(
        "Secret must be at least 5 characters",
        "secret"
      );
    }

    const response = await secretsAPI.patch(`/secrets/${secretId}`, req.body);

    res.json({
      success: true,
      message: "Secret partially updated",
      data: response.data,
    });
  } catch (error) {
    if (error instanceof ValidationError) {
      next(error);
    } else if (error.response?.status === 404) {
      next(new APIError("Secret not found", 404));
    } else {
      next(new APIError("Failed to patch secret", 500, error.message));
    }
  }
});

// ============================================
// ROUTES - DELETE OPERATION
// ============================================

// DELETE - Delete secret by ID
app.delete("/api/secrets/:id", async (req, res, next) => {
  const secretId = req.params.id;

  try {
    await secretsAPI.delete(`/secrets/${secretId}`);

    res.json({
      success: true,
      message: "Secret deleted successfully",
      deletedId: secretId,
    });
  } catch (error) {
    if (error.response?.status === 404) {
      next(new APIError("Secret not found", 404));
    } else {
      next(new APIError("Failed to delete secret", 500, error.message));
    }
  }
});

// ============================================
// ERROR HANDLING MIDDLEWARE
// ============================================

// 404 handler - Must be before error handler
app.use((req, res, next) => {
  res.status(404).json({
    success: false,
    error: "Not Found",
    message: `Route ${req.method} ${req.url} does not exist`,
  });
});

// Global error handler - Must have 4 parameters!
app.use((err, req, res, next) => {
  console.error("Error occurred:");
  console.error("Name:", err.name);
  console.error("Message:", err.message);
  console.error("Stack:", err.stack);

  // Set default values
  let statusCode = err.statusCode || 500;
  let message = err.message || "Internal Server Error";
  let details = null;

  // Handle ValidationError
  if (err instanceof ValidationError) {
    statusCode = 400;
    details = err.field;
  }

  // Send error response
  res.status(statusCode).json({
    success: false,
    error: err.name || "Error",
    message: message,
    ...(details && { details }),
    ...(process.env.NODE_ENV === "development" && {
      stack: err.stack,
    }),
  });
});

// ============================================
// START SERVER
// ============================================

app.listen(port, () => {
  console.log("=================================");
  console.log("üîê Secrets API Application üîê");
  console.log("=================================");
  console.log(`Server: http://localhost:${port}`);
  console.log(`API Base: ${API_BASE_URL}`);
  console.log("\nAvailable Endpoints:");
  console.log("  GET    /api/secrets           - Get all secrets");
  console.log("  GET    /api/secrets/random    - Get random secret");
  console.log("  GET    /api/secrets/:id       - Get secret by ID");
  console.log("  GET    /api/secrets/filter/:type - Filter secrets");
  console.log("  POST   /api/secrets           - Create new secret");
  console.log("  PUT    /api/secrets/:id       - Full update secret");
  console.log("  PATCH  /api/secrets/:id       - Partial update secret");
  console.log("  DELETE /api/secrets/:id       - Delete secret");
  console.log("=================================");
});
```

## Testing dengan Postman atau Thunder Client

### 1. GET All Secrets

```
GET http://localhost:3000/api/secrets
```

### 2. GET Random Secret

```
GET http://localhost:3000/api/secrets/random
```

### 3. GET Secret by ID

```
GET http://localhost:3000/api/secrets/1
```

### 4. Filter Secrets

```
GET http://localhost:3000/api/secrets/filter/score?value=8
```

### 5. CREATE New Secret

```
POST http://localhost:3000/api/secrets
Content-Type: application/json

{
    "secret": "I once ate 10 donuts in one sitting",
    "score": 7,
    "username": "donut_lover",
    "embarrassmentLevel": "high"
}
```

### 6. FULL UPDATE (PUT)

```
PUT http://localhost:3000/api/secrets/1
Content-Type: application/json

{
    "secret": "Updated complete secret",
    "score": 9,
    "username": "updated_user",
    "embarrassmentLevel": "extreme"
}
```

### 7. PARTIAL UPDATE (PATCH)

```
PATCH http://localhost:3000/api/secrets/1
Content-Type: application/json

{
    "score": 10
}
```

### 8. DELETE Secret

```
DELETE http://localhost:3000/api/secrets/1
```

## Error Handling Best Practices

Dari hasil search yang saya dapatkan, berikut adalah best practices untuk error handling di Express:

### 1. Custom Error Classes

Membuat custom error classes memudahkan error handling:

```javascript
class NotFoundError extends Error {
  constructor(message) {
    super(message);
    this.statusCode = 404;
    this.name = "NotFoundError";
  }
}

class UnauthorizedError extends Error {
  constructor(message) {
    super(message);
    this.statusCode = 401;
    this.name = "UnauthorizedError";
  }
}
```

### 2. Async Error Handler Wrapper

Untuk menghindari try-catch berulang:

```javascript
const asyncHandler = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

// Usage
app.get(
  "/secrets",
  asyncHandler(async (req, res) => {
    const secrets = await secretsAPI.get("/secrets");
    res.json(secrets.data);
  })
);
```

### 3. Error Handler Position

Error handler **HARUS** ditempatkan setelah semua routes:

```javascript
// ‚úÖ CORRECT ORDER
app.get('/route1', handler1);
app.post('/route2', handler2);

// 404 handler
app.use((req, res) => { ... });

// Error handler (4 parameters!)
app.use((err, req, res, next) => { ... });
```

### 4. Handle Unhandled Rejections

```javascript
process.on("unhandledRejection", (err) => {
  console.error("Unhandled Promise Rejection:", err.message);
  process.exit(1);
});

process.on("uncaughtException", (err) => {
  console.error("Uncaught Exception:", err.message);
  process.exit(1);
});
```

## Frontend Integration

### File public/index.html

```html
<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Secrets Manager</title>
    <link rel="stylesheet" href="/styles/style.css" />
  </head>
  <body>
    <div class="container">
      <h1>üîê Secrets Manager</h1>

      <!-- Create Form -->
      <div class="section">
        <h2>Create New Secret</h2>
        <form id="createForm">
          <input
            type="text"
            id="secret"
            placeholder="Your secret..."
            required
          />
          <input
            type="number"
            id="score"
            placeholder="Score (0-10)"
            min="0"
            max="10"
          />
          <input type="text" id="username" placeholder="Username" />
          <button type="submit">Create Secret</button>
        </form>
      </div>

      <!-- Display Secrets -->
      <div class="section">
        <h2>All Secrets</h2>
        <button onclick="loadSecrets()">Load Secrets</button>
        <button onclick="loadRandomSecret()">Random Secret</button>
        <div id="secretsList"></div>
      </div>

      <!-- Result -->
      <div id="result" class="result"></div>
    </div>

    <script>
      // Create secret
      document
        .getElementById("createForm")
        .addEventListener("submit", async (e) => {
          e.preventDefault();

          const data = {
            secret: document.getElementById("secret").value,
            score: parseInt(document.getElementById("score").value) || 5,
            username: document.getElementById("username").value || "Anonymous",
          };

          try {
            const response = await fetch("/api/secrets", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(data),
            });

            const result = await response.json();

            if (result.success) {
              showResult("Secret created successfully!", "success");
              document.getElementById("createForm").reset();
              loadSecrets();
            } else {
              showResult("Error: " + result.message, "error");
            }
          } catch (error) {
            showResult("Network error: " + error.message, "error");
          }
        });

      // Load all secrets
      async function loadSecrets() {
        try {
          const response = await fetch("/api/secrets");
          const result = await response.json();

          if (result.success) {
            displaySecrets(result.data);
          }
        } catch (error) {
          showResult("Error loading secrets: " + error.message, "error");
        }
      }

      // Load random secret
      async function loadRandomSecret() {
        try {
          const response = await fetch("/api/secrets/random");
          const result = await response.json();

          if (result.success) {
            displaySecrets([result.data]);
          }
        } catch (error) {
          showResult("Error loading random secret: " + error.message, "error");
        }
      }

      // Display secrets
      function displaySecrets(secrets) {
        const listDiv = document.getElementById("secretsList");
        listDiv.innerHTML = "";

        secrets.forEach((secret) => {
          const secretDiv = document.createElement("div");
          secretDiv.className = "secret-item";
          secretDiv.innerHTML = `
                    <p><strong>Secret:</strong> ${secret.secret}</p>
                    <p><strong>Score:</strong> ${secret.score}/10</p>
                    <p><strong>By:</strong> ${secret.username}</p>
                    <button onclick="deleteSecret(${secret.id})">Delete</button>
                `;
          listDiv.appendChild(secretDiv);
        });
      }

      // Delete secret
      async function deleteSecret(id) {
        if (!confirm("Delete this secret?")) return;

        try {
          const response = await fetch(`/api/secrets/${id}`, {
            method: "DELETE",
          });

          const result = await response.json();

          if (result.success) {
            showResult("Secret deleted!", "success");
            loadSecrets();
          } else {
            showResult("Error: " + result.message, "error");
          }
        } catch (error) {
          showResult("Error deleting secret: " + error.message, "error");
        }
      }

      // Show result message
      function showResult(message, type) {
        const resultDiv = document.getElementById("result");
        resultDiv.textContent = message;
        resultDiv.className = `result ${type}`;
        resultDiv.style.display = "block";

        setTimeout(() => {
          resultDiv.style.display = "none";
        }, 3000);
      }

      // Load secrets on page load
      loadSecrets();
    </script>
  </body>
</html>
```

## Best Practices Summary

**Validation**: Selalu validasi input sebelum mengirim ke API atau menyimpan ke database.

**Error Handling**: Gunakan custom error classes dan global error handler dengan 4 parameters.

**Axios Interceptors**: Gunakan untuk cross-cutting concerns seperti logging dan token refresh.

**Environment Variables**: Jangan hardcode API URLs atau keys, simpan di .env file.

**Status Codes**: Gunakan HTTP status codes yang tepat (200, 201, 400, 404, 500).

**Async/Await**: Lebih readable daripada promises dengan .then() chains.

**Try-Catch**: Selalu wrap async operations dalam try-catch atau gunakan asyncHandler wrapper.

**Logging**: Log errors untuk debugging tapi jangan expose sensitive data ke client.

---

**Ringkasan**: Full REST API interaction melibatkan implementasi complete CRUD operations dengan proper error handling dan validation. Axios interceptors memberikan powerful way untuk handle cross-cutting concerns seperti authentication, logging, dan error transformation. Custom error classes dan global error handler dengan 4 parameters adalah essential untuk production-ready applications. Validation di input layer mencegah bad data masuk ke system. Integration dengan frontend menggunakan Fetch API menunjukkan full-stack workflow dari client request hingga server response, menciptakan aplikasi yang robust, maintainable, dan user-friendly.
